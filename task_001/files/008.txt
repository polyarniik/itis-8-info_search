<!DOCTYPE html>

<html data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D" lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1.0,viewport-fit=cover,maximum-scale=1,user-scalable=0" name="viewport"/>
<meta content="unsafe-url" name="referrer"/>
<title>Создаем свой собственный язык программирования с использованием LLVM. Часть 3: Генерация кода / Хабр</title>







<meta content="2.112.0" name="habr-version"/>
<meta content="444736788986613" data-vue-meta="ssr" property="fb:app_id"/><meta content="472597926099084" data-vue-meta="ssr" property="fb:pages"/><meta content="summary_large_image" data-vue-meta="ssr" name="twitter:card"/><meta content="@habr_com" data-vue-meta="ssr" name="twitter:site"/><meta content="Хабр" data-vmid="og:site_name" data-vue-meta="ssr" property="og:site_name"/><meta content="Создаем свой собственный язык программирования с использованием LLVM. Часть 3: Генерация кода" data-vmid="og:title" data-vue-meta="ssr" property="og:title"/><meta content="Создаем свой собственный язык программирования с использованием LLVM. Часть 3: Генерация кода" data-vmid="twitter:title" data-vue-meta="ssr" name="twitter:title"/><meta content="Создаем свой собственный язык программирования с использованием LLVM. Часть 3: Генерация кода" data-vmid="aiturec:title" data-vue-meta="ssr" name="aiturec:title"/><meta content="В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье..." data-vmid="description" data-vue-meta="ssr" name="description"/><meta content="В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье..." data-vmid="description:itemprop" data-vue-meta="ssr" itemprop="description"/><meta content="В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье..." data-vmid="og:description" data-vue-meta="ssr" property="og:description"/><meta content="В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье..." data-vmid="twitter:description" data-vue-meta="ssr" name="twitter:description"/><meta content="В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье..." data-vmid="aiturec:description" data-vue-meta="ssr" property="aiturec:description"/><meta content="https://habr.com/share/publication/717886/53623adcff3ca3323f6bb85c87a920f5/" data-vmid="image:itemprop" data-vue-meta="ssr" itemprop="image"/><meta content="https://habr.com/share/publication/717886/53623adcff3ca3323f6bb85c87a920f5/" data-vmid="og:image" data-vue-meta="ssr" property="og:image"/><meta content="1200" data-vmid="og:image:width" data-vue-meta="ssr" property="og:image:width"/><meta content="630" data-vmid="og:image:height" data-vue-meta="ssr" property="og:image:height"/><meta content="https://habr.com/share/publication/717886/53623adcff3ca3323f6bb85c87a920f5/" data-vmid="aiturec:image" data-vue-meta="ssr" property="aiturec:image"/><meta content="https://habr.com/share/publication/717886/53623adcff3ca3323f6bb85c87a920f5/" data-vmid="twitter:image" data-vue-meta="ssr" name="twitter:image"/><meta content="https://habr.com/share/publication/717886/53623adcff3ca3323f6bb85c87a920f5/?format=vk" data-vmid="vk:image" data-vue-meta="ssr" property="vk:image"/><meta content="717886" data-vmid="aiturec:item_id" data-vue-meta="ssr" property="aiturec:item_id"/><meta content="2023-02-19T16:30:58.000Z" data-vmid="aiturec:datetime" data-vue-meta="ssr" property="aiturec:datetime"/><meta content="https://habr.com/ru/post/717886/" data-vmid="og:url" data-vue-meta="ssr" property="og:url"/><meta content="article" data-vmid="og:type" data-vue-meta="ssr" property="og:type"/><meta content="ru_RU" data-vmid="og:locale" data-vue-meta="ssr" property="og:locale"/><meta content="llvm, компиляторы, c++" data-vue-meta="ssr" name="keywords"/>

<meta content="#303b44" name="apple-mobile-web-app-status-bar-style"/>
<meta content="#629FBC" name="msapplication-TileColor"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="yes" name="mobile-web-app-capable"/>
































</head>
<body>
<div data-async-called="true" data-server-rendered="true" id="app"><div class="tm-layout__wrapper"><!-- --> <div></div> <div class="tm-feature tm-feature"><!-- --></div> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><div class="tm-header__burger-nav"><button class="tm-header__button tm-header__button_burger" type="button"><svg class="tm-svg-img tm-header__icon tm-header__icon-burger" height="16" width="16"><title>Меню</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#header-burger"></use></svg></button></div> <span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_ru" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <!-- --> <div class="tm-header-user-menu tm-header_user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search" height="24" width="24"><title>Поиск</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#search"></use></svg></a> <!-- --> <!-- --> <!-- --> <div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="menu-toggle-guest"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_white" height="24" width="24"><title>Профиль</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#header-user"></use></svg></button> <!-- --></div> <!-- --></div></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <!-- --> <!-- --> <div class="tm-page-width"></div> <main class="tm-layout__container"><div class="tm-page" data-async-called="true" hl="ru"><div class="tm-page-width"><!-- --> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><!-- --> <div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__arrow" height="24" width="24"><title>Обновить</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet tm-article-snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" href="/ru/users/DCSinpo/" title="DCSinpo"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue" height="32" width="32"><!-- --> <use xlink:href="/img/megazord-v28.78dd0d98..svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a class="tm-user-info__username" href="/ru/users/DCSinpo/">
      DCSinpo
      <!-- --></a> <span class="tm-article-datetime-published"><time datetime="2023-02-19T16:30:58.000Z" title="2023-02-19, 19:30">6 часов назад</time></span></span></span></div> <!-- --></div> <h1 class="tm-article-snippet__title tm-article-snippet__title_h1" lang="ru"><span>Создаем свой собственный язык программирования с использованием LLVM. Часть 3: Генерация кода</span></h1> <div class="tm-article-snippet__stats"><!-- --> <div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#clock"></use></svg></span> <span class="tm-article-reading-time__label">
    29 мин
  </span></div> <span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#counter-views"></use></svg> <span class="tm-icon-counter__value">1.1K</span></span></div> <div class="tm-article-snippet__hubs-container"><div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a class="tm-article-snippet__hubs-item-link" href="/ru/hub/open_source/"><span>Open source</span> <span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span></a></span><span class="tm-article-snippet__hubs-item"><a class="tm-article-snippet__hubs-item-link" href="/ru/hub/programming/"><span>Программирование</span> <span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span></a></span><span class="tm-article-snippet__hubs-item"><a class="tm-article-snippet__hubs-item-link" href="/ru/hub/compilers/"><span>Компиляторы</span> <span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span></a></span></div></div> <!-- --> <!-- --> <!-- --></div></div> <!-- --> <div class="tm-article-body" data-gallery-root="" lang="ru"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В предыдущих статьях мы рассмотрели и реализовали лексический и синтаксический анализаторы, а так же реализовали семантический анализ для нашего учебного языка, что дало нам основу. В данной статье мы продолжим начатое и реализуем генерацию кода для LLVM IR.</p><h3>LLVM</h3><p>LLVM это набор компиляторов и инструментов, которые могут быть использованы для создания фронтендов для любого языка программирования и бэкендов для любой архитектуры набора команд. LLVM разработан вокруг языко-независимого промежуточного представления (LLVM IR), который служит в качестве портативного, высокоуровневого языка ассемблера, который может быть оптимизирован при помощи различных преобразований.</p><p>Программа LLVM состоит из модулей, которые являются единицами трансляции исходной программы. Каждый модуль содержит функции, глобальные переменные и элементы таблицы символов. Модули могут быть объединены с использованием линковщика LLVM.</p><p>Определение функции представляет собой прототип самой функции (ее имя, типы ее параметров, тип возвращаемого значения и некоторые другие необязательные части, такие как способ линковки, ее видимость, способ передачи параметров и др.), а также ее тела, которое может состоять из одного или нескольких базовых блоков.</p><p>Базовый блок — является последовательностью операций (инструкций), которые образуют логику базового блока. Любой базовый блок должен завершаться инструкцией терминатором (условный или безусловный переход, возврат из функции и др.).</p><p>Система типов LLVM поддерживает большое количество типов данных, которые делятся на (рассмотрим только те типы, которые мы будем использовать в процессе реализации нашего учебного языка):</p><ol><li><p>Целые числа различной разрядности (например i1, i8, i32, i64);</p></li><li><p>Числа с плавающей точкой (например float, double);</p></li><li><p>void;</p></li><li><p>Указатели (например i64*);</p></li><li><p>Массивы (например [20 x i32]);</p></li><li><p>Структуры (например { i32, double, i64 });</p></li><li><p>Функции (например i32 (i32, double)).</p></li></ol><p>Основная особенность LLVM IR состоит в том, что он записан в формате SSA (Static Single Assignment), при которой каждому регистру значение может быть присвоено только один раз. Что упрощает анализ потока данных программы и производить различные оптимизации.</p><p>Но такая форма накладывает некоторые ограничения, если в программе есть переменные, которые могут изменяться, для решения этой проблемы используется инструкция phi, которая присваивает значение на основе того, из какого блока был переход в блок содержащую инструкцию phi. Например:</p><pre><code>Loop:       ; Infinite loop that counts from 0 on up...
  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
  %nextindvar = add i32 %indvar, 1
  br label %Loop</code></pre><p>Более подробнее про LLVM IR можно почитать в [1], а как можно все это применить в [2].</p><p>Далее мы рассмотрим генерацию кода для различных элементов языка (мы будем использовать JIT, реализацию которого можно будет посмотреть в полном исходном коде проекта на <a href="https://github.com/dc-sinpo/simple/tree/part01" rel="noopener noreferrer nofollow">github</a>, либо почитать в [3]).</p><h3>Генерация кода для типов</h3><p>Для начала посмотрим, что изменилось в описании типа для генерации кода:</p><pre><code class="cpp">struct TypeAST { 
   /// Получить тип LLVM для данной ветки дерева
  virtual llvm::Type* getType() = 0; 

  llvm::Type* ThisType; ///&lt; сгенерированный тип LLVM
};</code></pre><p>Сама же генерация для веток дерева, которые относятся к типам очень простая, нужно всего сопоставить тип языка к аналогичному типу в LLVM:</p><details class="spoiler"><summary>Hidden text</summary><div class="spoiler__content"><pre><code class="cpp">Type* BuiltinTypeAST::getType() {
  static Type* builtinTypes[] = {
    Type::getVoidTy(getGlobalContext()),
    Type::getInt1Ty(getGlobalContext()),
    Type::getInt32Ty(getGlobalContext()),
    Type::getDoubleTy(getGlobalContext()),
    Type::getInt8Ty(getGlobalContext()),
    Type::getInt8PtrTy(getGlobalContext())
  };

  if (ThisType) {
    return ThisType;
  }

  return ThisType = builtinTypes[TypeKind];
}

Type* FuncTypeAST::getType() {
  // Генерируем тип только один раз
  if (ThisType) {
    return ThisType;
  }

  // Если ReturnType не указан, то указываем "void"
  Type* returnType = (ReturnType ? ReturnType-&gt;getType() : 
    Type::getVoidTy(getGlobalContext()));

  if (Params.empty()) {
    // Возвращаем функцию без параметров
    return ThisType = FunctionType::get(returnType, false);
  }
  
  std::vector&lt; Type* &gt; params;

  // Создаем список параметров
  for (ParameterList::iterator it = Params.begin(), 
    end = Params.end(); it != end; ++it) {
    params.push_back((*it)-&gt;Param-&gt;getType());
  }

  // Создаем тип для функции с параметрами
  return ThisType = FunctionType::get(returnType, params, false);
}</code></pre><p></p></div></details><h3>Генерация кода для выражений</h3><p>Рассмотрим изменения необходимые для генерации кода выражений:</p><pre><code class="cpp">struct ExprAST { 
  /// Генерация кода для выражения, которое может быть использовано в левой 
  /// части "="
  virtual llvm::Value *getLValue(SLContext &amp;Context); 
  /// Генерация кода для выражения, которое может быть использовано в правой
  /// части "="
  virtual llvm::Value *getRValue(SLContext &amp;Context) = 0; 
};</code></pre><p>Зачем нужны две функции для lvalue и rvalue? Рассмотрим на примере выражения</p><pre><code class="cpp">i</code></pre><p>rvalue этого выражения будет значение этой переменной, а lvalue будет адрес этой переменной в памяти, который может быть использована для присвоения нового значения.</p><p>Рассмотрим функции, которые будут использоваться во время генерации очень часто:</p><details class="spoiler"><summary>Hidden text</summary><div class="spoiler__content"><pre><code class="cpp">/// Сгенерировать код для целочисленной константы
ConstantInt* getConstInt(uint64_t value) {
  return ConstantInt::get(Type::getInt32Ty(getGlobalContext()),
                          value, true);
}

/// Конвертировать тип выражения в "bool"
/// \param[in] val — значение для конвертации
/// \param[in] type — тип изначального выражения
/// \param[in] builder — конструктор LLVM IR
Value* promoteToBool(Value* val,
                     TypeAST* type,
                     IRBuilder&lt; &gt;&amp; builder) {
  if (type == BuiltinTypeAST::get(TypeAST::TI_Bool)) {
    // Это уже "bool"
    return val;
  }

  if (type-&gt;isInt()) {
    // Для целочисленного типа генерируем сравнение с 0
    return builder.CreateICmpNE(val,
                                ConstantInt::get(
                                  type-&gt;getType(),
                                  0)
                               );
  } else {
    assert(type-&gt;isFloat());
    // Для числа с плавающей точкой генерируем сравнение с 0.0
    return builder.CreateFCmpUNE(val, ConstantFP::get(
      Type::getDoubleTy(getGlobalContext()), 0.0));
  }
}
Рассмотрим реализацию генерации кода для самих выражений:
Value* ExprAST::getLValue(SLContext&amp; ) {
  assert(0 &amp;&amp; "");
  return nullptr;
}

Value* IntExprAST::getRValue(SLContext&amp; ) {
  // Создать целочисленную константу нужного типа с нужным 
  // значением
  return ConstantInt::get(ExprType-&gt;getType(), Val, true);
}

Value* FloatExprAST::getRValue(SLContext&amp; ) {
  // Создать константу для числа с плавающей точкой нужного типа с 
  // нужным значением
  return ConstantFP::get(ExprType-&gt;getType(), Val);
}

Value* IdExprAST::getLValue(SLContext&amp; Context) {
  // Получить адрес переменной (сам адрес сгенерирует SymbolAST, 
  // на который ссылается переменная)
  return ThisSym-&gt;getValue(Context);
}

Value* IdExprAST::getRValue(SLContext&amp; Context) {
  if (isa&lt;FuncDeclAST&gt;(ThisSym)) {
    // Особая обработка для функций
    return ThisSym-&gt;getValue(Context);
  }

  // Для остальных вариантов нужно сгенерировать инструкцию "load"
  return Context.TheBuilder-&gt;CreateLoad(
    ExprType-&gt;getType(),
    ThisSym-&gt;getValue(Context), 
    StringRef(Val-&gt;Id, Val-&gt;Length)
  );
}

Value* CastExprAST::getRValue(SLContext&amp; Context) {
  // Сначала проверяем, что это преобразование в целочисленный тип
  if (ExprType-&gt;isInt()) {
    if (Val-&gt;ExprType-&gt;isBool()) {
      // Если исходный тип "bool", то дополняем 0
      return Context.TheBuilder-&gt;CreateZExt(
        Val-&gt;getRValue(Context), 
        ExprType-&gt;getType()
      );
    }

    assert(Val-&gt;ExprType-&gt;isFloat());
    // Генерируем преобразование "float" в "int"
    return Context.TheBuilder-&gt;CreateFPToSI(
      Val-&gt;getRValue(Context), 
      ExprType-&gt;getType()
    );
  }

  if (ExprType-&gt;isBool()) {
    // Для преобразования в "bool"
    return promoteToBool(Val-&gt;getRValue(Context), Val-&gt;ExprType, 
      *Context.TheBuilder);
  } else if (Val-&gt;ExprType-&gt;isInt()) {
    // Преобразование "int" в "float" 
    return Context.TheBuilder-&gt;CreateSIToFP(
      Val-&gt;getRValue(Context), 
      ExprType-&gt;getType()
    );
  } else if (Val-&gt;ExprType-&gt;isBool()) {
    // Преобразование "bool" в "float"
    return Context.TheBuilder-&gt;CreateUIToFP(
      Val-&gt;getRValue(Context),
      ExprType-&gt;getType()
    );
  }

  assert(0 &amp;&amp; "should never be reached");
  return nullptr;
}

Value* UnaryExprAST::getRValue(SLContext&amp; Context) {
  assert(0 &amp;&amp; "Should never happen");
  return nullptr;
}

Value* BinaryExprAST::getRValue(SLContext&amp; Context) {
  // Сначала необходимо проверить все специальные случаи

  // =
  if (Op == tok::Assign) {
    
    // Генерируем код для правой части выражения
    Value* right = RightExpr-&gt;getRValue(Context);
    // Получаем адрес по которому нужно сохранить значение
    Value* res = LeftExpr-&gt;getLValue(Context);

    // Генерируем инструкцию "store"
    Context.TheBuilder-&gt;CreateStore(right, res);
    return right;
  }

  // ,
  if (Op == tok::Comma) {
    // Генерируем код для левого и правого операнда
    LeftExpr-&gt;getRValue(Context);
    Value* rhs = RightExpr-&gt;getRValue(Context);
    // Возвращаем правый операнд
    return rhs;
  }

  // Постфиксная версия операторов ++ и --
  if (Op == tok::PlusPlus || Op == tok::MinusMinus) {
    // Получаем адрес переменной, а так же ее значение
    Value* var = LeftExpr-&gt;getLValue(Context);
    Value* val = LeftExpr-&gt;getRValue(Context);

    if (Op == tok::PlusPlus) {
      // Создать целочисленную константу 1 и прибавить ее к 
      // загруженному ранее значению
      Value* tmp = getConstInt(1);
      tmp = Context.TheBuilder-&gt;CreateAdd(val, tmp, "inctmp");
      // Сохранить новое значение и вернуть старое значение
      Context.TheBuilder-&gt;CreateStore(tmp, var);
      return val;
    } else {
      // Создать целочисленную константу -1 и прибавить ее к 
      // загруженному ранее значению
      Value* tmp = getConstInt(~0ULL);
      tmp = Context.TheBuilder-&gt;CreateAdd(val, tmp, "dectmp");
      // Сохранить новое значение и вернуть старое значение
      Context.TheBuilder-&gt;CreateStore(tmp, var);
      return val;
    }
  }

  // ||
  if (Op == tok::LogOr) {
    // Псевдокод для оператора ||

    //if (bool result = (left != 0))
    //  return result;
    //else
    //  return (right != 0);

    // Генерация кода для левого операнда
    Value* lhs = LeftExpr-&gt;getRValue(Context);
    // Произвести преобразование в "bool"
    lhs = promoteToBool(lhs, LeftExpr-&gt;ExprType, 
                        *Context.TheBuilder);

    // Создать блоки для ветки "false" и "result" (куда будет 
    // возвращено управление для продолжения работы программы)
    BasicBlock* condBB = Context.TheBuilder-&gt;GetInsertBlock();
    BasicBlock* resultBB = BasicBlock::Create(
      getGlobalContext(),
      "result"
    );
    BasicBlock* falseBB = BasicBlock::Create(
      getGlobalContext(),
      "false"
    );

    // Создать условный переход к "result" или "false" в 
    // зависимости от истинности левого операнда
    Context.TheBuilder-&gt;CreateCondBr(lhs, resultBB, falseBB);

    // Добавить блок "false" к функции (для которой генерируем код) 
    // и переходим к генерации кода для нее
    Context.TheFunction-&gt;getBasicBlockList().push_back(falseBB);
    Context.TheBuilder-&gt;SetInsertPoint(falseBB);
    // Генерация кода для правого операнда
    Value* rhs = RightExpr-&gt;getRValue(Context);
    // Обновляем блок "false", т. к. код для правого операнда мог 
    // ее сменить
    falseBB = Context.TheBuilder-&gt;GetInsertBlock();
    // Произвести преобразование в "bool"
    rhs = promoteToBool(
      rhs,
      RightExpr-&gt;ExprType,
      *Context.TheBuilder
    );
    // Производим безусловный переход к "result"
    Context.TheBuilder-&gt;CreateBr(resultBB);

    // Добавить блок "result" к функции (для которой генерируем код)
    // и переходим к генерации кода для нее
    Context.TheFunction-&gt;getBasicBlockList().push_back(resultBB);
    Context.TheBuilder-&gt;SetInsertPoint(resultBB);

    // Создаем PHI значение, которое будет содержать значение в 
    // зависимости от того какая ветка была выбрана при обработке
    // изначального условия
    PHINode* PN = Context.TheBuilder-&gt;CreatePHI(
      Type::getInt1Ty(getGlobalContext()),
      2
    );

    PN-&gt;addIncoming(lhs, condBB);
    PN-&gt;addIncoming(rhs, falseBB);

    return PN;
  }

  // &amp;&amp;
  if (Op == tok::LogAnd) {
    // Псевдокод для оператора &amp;&amp;

    //if (left != 0 &amp;&amp; right != 0)
    //    return true;
    //else
    //  return false;

    // Генерируем код для левой операнда
    Value* lhs = LeftExpr-&gt;getRValue(Context);
    // Произвести преобразование в "bool"
    lhs = promoteToBool(
      lhs,
      LeftExpr-&gt;ExprType,
      *Context.TheBuilder
    );

    // Создать блоки для ветки "true" и "result" (куда будет 
    // возвращено управление для продолжения работы программы)
    BasicBlock* condBB = Context.TheBuilder-&gt;GetInsertBlock();
    BasicBlock* resultBB = BasicBlock::Create(
      getGlobalContext(),
      "result"
    );
    BasicBlock* trueBB = BasicBlock::Create(
      getGlobalContext(),
      "true"
    );

    // Создать условный переход к "true" или "result" в 
    // зависимости от истинности левого операнда
    Context.TheBuilder-&gt;CreateCondBr(lhs, trueBB, resultBB);

    // Добавить блок "true" к функции (для которой генерируем код) 
    // и переходим к генерации кода для нее
    Context.TheFunction-&gt;getBasicBlockList().push_back(trueBB);
    Context.TheBuilder-&gt;SetInsertPoint(trueBB);
    // Генерация кода для правого операнда
    Value* rhs = RightExpr-&gt;getRValue(Context);
    // Обновляем блок "true", т. к. код для правого операнда мог 
    // ее сменить
    trueBB = Context.TheBuilder-&gt;GetInsertBlock();
    // Произвести преобразование в "bool"
    rhs = promoteToBool(
      rhs,
      RightExpr-&gt;ExprType,
      *Context.TheBuilder
    );
    // Производим безусловный переход к "result"
    Context.TheBuilder-&gt;CreateBr(resultBB);

    // Добавить блок "result" к функции (для которой генерируем 
    // код) и переходим к генерации кода для нее
    Context.TheFunction-&gt;getBasicBlockList().push_back(resultBB);
    Context.TheBuilder-&gt;SetInsertPoint(resultBB);

    // Создаем PHI значение, которое будет содержать значение в 
    // зависимости от того какая ветка была выбрана при обработке 
    // изначального условия
    PHINode* PN = Context.TheBuilder-&gt;CreatePHI(
      Type::getInt1Ty(getGlobalContext()),
      2
    );

    PN-&gt;addIncoming(lhs, condBB);
    PN-&gt;addIncoming(rhs, trueBB);

    return PN;
  }

  // Генерируем код для обоих операндов
  Value* lhs = LeftExpr-&gt;getRValue(Context);
  Value* rhs = RightExpr-&gt;getRValue(Context);

  // Проверяем тип выражения на то, что это "int"
  if (LeftExpr-&gt;ExprType == BuiltinTypeAST::get(TypeAST::TI_Int)) {
    // Генерация кода в соответствии с операцией
    switch (Op) {
      case tok::Plus:
        return Context.TheBuilder-&gt;CreateAdd(lhs, rhs, "addtmp");
      case tok::Minus:
        return Context.TheBuilder-&gt;CreateSub(lhs, rhs, "subtmp");
      case tok::Mul:
        return Context.TheBuilder-&gt;CreateMul(lhs, rhs, "multmp");
      case tok::Div:
        return Context.TheBuilder-&gt;CreateSDiv(lhs, rhs, "divtmp");
      case tok::Mod:
        return Context.TheBuilder-&gt;CreateSRem(lhs, rhs, "remtmp");
      case tok::BitOr:
        return Context.TheBuilder-&gt;CreateOr(lhs, rhs, "ortmp");
      case tok::BitAnd:
        return Context.TheBuilder-&gt;CreateAnd(lhs, rhs, "andtmp");
      case tok::BitXor:
        return Context.TheBuilder-&gt;CreateXor(lhs, rhs, "xortmp");
      case tok::LShift:
        return Context.TheBuilder-&gt;CreateShl(lhs, rhs, "shltmp");
      case tok::RShift:
        return Context.TheBuilder-&gt;CreateAShr(lhs, rhs, "shrtmp");
      case tok::Less:
        return Context.TheBuilder-&gt;CreateICmpSLT(lhs, rhs, "cmptmp");
      case tok::Greater:
        return Context.TheBuilder-&gt;CreateICmpSGT(lhs, rhs, "cmptmp");
      case tok::LessEqual:
        return Context.TheBuilder-&gt;CreateICmpSLE(lhs, rhs, "cmptmp");
      case tok::GreaterEqual:
        return Context.TheBuilder-&gt;CreateICmpSGE(lhs, rhs, "cmptmp");
      case tok::Equal:
        return Context.TheBuilder-&gt;CreateICmpEQ(lhs, rhs, "cmptmp");
      case tok::NotEqual:
        return Context.TheBuilder-&gt;CreateICmpNE(lhs, rhs, "cmptmp");
      default:
        assert(0 &amp;&amp; "Invalid integral binary operator");
        return nullptr;
    }
  }
  
  // Генерация кода в соответствии с операцией
  switch (Op) {
    case tok::Plus:
      return Context.TheBuilder-&gt;CreateFAdd(lhs, rhs, "addtmp");
    case tok::Minus:
      return Context.TheBuilder-&gt;CreateFSub(lhs, rhs, "subtmp");
    case tok::Mul:
      return Context.TheBuilder-&gt;CreateFMul(lhs, rhs, "multmp");
    case tok::Div:
      return Context.TheBuilder-&gt;CreateFDiv(lhs, rhs, "divtmp");
    case tok::Mod:
      return Context.TheBuilder-&gt;CreateFRem(lhs, rhs, "remtmp");
    case tok::Less:
      return Context.TheBuilder-&gt;CreateFCmpULT(lhs, rhs, "cmptmp");
    case tok::Greater:
      return Context.TheBuilder-&gt;CreateFCmpUGT(lhs, rhs, "cmptmp");
    case tok::LessEqual:
      return Context.TheBuilder-&gt;CreateFCmpULE(lhs, rhs, "cmptmp");
    case tok::GreaterEqual:
      return Context.TheBuilder-&gt;CreateFCmpUGE(lhs, rhs, "cmptmp");
    case tok::Equal:
      return Context.TheBuilder-&gt;CreateFCmpUEQ(lhs, rhs, "cmptmp");
    case tok::NotEqual:
      return Context.TheBuilder-&gt;CreateFCmpUNE(lhs, rhs, "cmptmp");
    default:
      assert(0 &amp;&amp; "Invalid floating point binary operator");
      return nullptr;
  }
}

/// Генерация кода для тернарного оператора (в отличии от "if" 
/// данный оператор возвращает результирующее значение и может 
/// быть использован в других выражениях)
/// \param[in] Context - контекст
/// \param[in] Cond — условное выражение
/// \param[in] IfExpr — выражение, если условие истинно
/// \param[in] ElseExpr — выражение, если условие ложно
/// \param[in] isLValue - true — если нужен адрес (или lvalue)
Value* generateCondExpr(
  SLContext&amp; Context,
  ExprAST* Cond,
  ExprAST* IfExpr, 
  ExprAST* ElseExpr,
  bool isLValue) {
  // Генерация кода для условия
  Value* cond = Cond-&gt;getRValue(Context);
  // Произвести преобразование в "bool"
  cond = promoteToBool(cond, Cond-&gt;ExprType, *Context.TheBuilder);

  // Создаем блоки для веток "then", "else" и "ifcont"
  BasicBlock* thenBB = BasicBlock::Create(
    getGlobalContext(),
    "then", 
    Context.TheFunction
  );
  BasicBlock* elseBB = BasicBlock::Create(
    getGlobalContext(), 
    "else"
  );
  BasicBlock* mergeBB = BasicBlock::Create(
    getGlobalContext(), 
    "ifcont"
  );

  // Создать условный переход на "then" или "else", в зависимости
  // от истинности условия
  Context.TheBuilder-&gt;CreateCondBr(cond, thenBB, elseBB);
  // Set insert point to a then branch
  Context.TheBuilder-&gt;SetInsertPoint(thenBB);

  // Генерация кода для ветки "then"
  Value* thenValue;
  
  // Генерируем lvalue или rvalue
  if (isLValue) {
    thenValue = IfExpr-&gt;getLValue(Context);
  } else {
    thenValue = IfExpr-&gt;getRValue(Context);
  }

  // Создаем безусловный переход на "ifcont" и обновляем блок 
  // "then", т. к. он мог смениться
  Context.TheBuilder-&gt;CreateBr(mergeBB);
  thenBB = Context.TheBuilder-&gt;GetInsertBlock();

  // Добавить блок "else" к функции (для которой генерируем код) 
  // и переходим к генерации кода для нее
  Context.TheFunction-&gt;getBasicBlockList().push_back(elseBB);
  Context.TheBuilder-&gt;SetInsertPoint(elseBB);

  Value* elseValue;
  
  // Генерируем lvalue или rvalue
  if (isLValue) {
    elseValue = ElseExpr-&gt;getLValue(Context);
  } else {
    elseValue = ElseExpr-&gt;getRValue(Context);
  }

  // Создаем безусловный переход на "ifcont" и обновляем блок 
  // "else", т. к. он мог смениться
  Context.TheBuilder-&gt;CreateBr(mergeBB);
  elseBB = Context.TheBuilder-&gt;GetInsertBlock();

  // Создаем безусловный переход на "ifcont" и обновляем блок 
  // "else", т. к. он мог смениться
  Context.TheFunction-&gt;getBasicBlockList().push_back(mergeBB);
  Context.TheBuilder-&gt;SetInsertPoint(mergeBB);

  // Если результат выражения имеет тип "void", то мы больше ничего
  // не делаем
  if (!IfExpr-&gt;ExprType || IfExpr-&gt;ExprType-&gt;isVoid()) {
    return nullptr;
  }

  // Создаем PHI значение, которое будет содержать значение в 
  // зависимости от того какая ветка была выбрана при обработке
  // изначального условия
  PHINode* PN;
  
  if (isLValue) {
    // Для lvalue тип выражения является указателем
    PN = Context.TheBuilder-&gt;CreatePHI(
      PointerType::get(IfExpr-&gt;ExprType-&gt;getType(), 0),
      2
    );
  } else {
    PN = Context.TheBuilder-&gt;CreatePHI(
      IfExpr-&gt;ExprType-&gt;getType(),
      2
    );
  }

  PN-&gt;addIncoming(thenValue, thenBB);
  PN-&gt;addIncoming(elseValue, elseBB);
  
  return PN;
}

Value* CondExprAST::getLValue(SLContext&amp; Context) {
  return generateCondExpr(Context, Cond, IfExpr, ElseExpr, true);
}

Value* CondExprAST::getRValue(SLContext&amp; Context) {
  return generateCondExpr(Context, Cond, IfExpr, ElseExpr, false);
}

Value* CallExprAST::getRValue(SLContext&amp; Context) {
  Value* callee = nullptr;
  std::vector&lt; Value* &gt; args;
  ExprList::iterator it = Args.begin();

  assert(isa&lt;FuncDeclAST&gt;(CallFunc));
  FuncDeclAST* funcDecl = (FuncDeclAST*)CallFunc;
  Type* funcRawType = CallFunc-&gt;getType()-&gt;getType();
  assert(isa&lt;FunctionType&gt;(funcRawType));
  FunctionType* funcType = static_cast&lt;FunctionType*&gt;(funcRawType);

  // Получаем адрес функции
  callee = CallFunc-&gt;getValue(Context);

  // Производим генерацию кода для каждого аргумента функции и 
  // добавляем их к списку аргументов функции
  for (ExprList::iterator end = Args.end(); it != end; ++it) {
    Value* v = (*it)-&gt;getRValue(Context);
    args.push_back(v);
  }
  
  // Генерируем вызов функции
  return Context.TheBuilder-&gt;CreateCall(funcType, callee, args);
}</code></pre><p></p></div></details><h3>Генерация кода для инструкций</h3><p>Рассмотрим изменения необходимые для генерации кода инструкций:</p><pre><code class="cpp">struct StmtAST { 
  /// Генерация кода для инструкции
  virtual llvm::Value* generateCode(SLContext&amp; Context); 
}; 
struct BlockStmtAST : StmtAST { 
  /// Генерация кода для инструкции
  llvm::Value* generateCode(SLContext&amp; Context); 
  /// Генерация кода для вложенных интсрукций
  /// \param[in] Context - контекст
  /// \param[in] it — начало
  /// \param[in] end — конец
  /// \note Вспомогательная функция для генерации кода для блока, нужна
  ///  т. к. некоторые конструкции нуждаются в специальной обработке
  ///  (например конструкторы и деструкторы) 
  llvm::Value* generatePartialCode(SLContext&amp; Context, StmtList::iterator it, 
    StmtList::iterator end); 
};</code></pre><p>Если язык, который вы хотите реализовать, достаточно сложный и поддерживает большое количество управляющих конструкций, то при генерации кода нужно принять решение, как сделать так что бы генерация кода была с одной стороны простой, а с другой стороны эффективной. Это особенно актуально, если язык поддерживает элементы ООП. Например если взять язык С++, то если мы где-то в программе создали экземпляр класса, у которого есть деструктор, то компилятор должен добавить вызов деструктора для объекта во всех местах, где данный объект выходит из своей области видимости (более подробно этот кейс мы рассмотрим в одной из следующих частей серии, в которой мы добавим поддержку классов).</p><p>Для упрощения генерации кода для инструкций и управляющих конструкций мы будем использовать следующую структуру:</p><pre><code class="cpp">struct LandingPadAST { 
  /// Получить переменную, которая будет хранить возвращаемое значение функции
  llvm::Value* getReturnValue(); 
  
  /// значение для возврата (нудно использовать getReturnValue)
  llvm::Value* ReturnValue; 
  llvm::BasicBlock* BreakLoc; ///&lt; блок для возврата по "break"
  llvm::BasicBlock* ContinueLoc; ///&lt; блок для возврата по "continue"
  llvm::BasicBlock* ReturnLoc; ///&lt; блок для возврата по "return"
  /// блок для продолжения нормального течения функции
  llvm::BasicBlock* FallthroughLoc;
}; </code></pre><p>Во время генерации кода для тела функции мы будем следовать такому подходу, что если тип возвращаемого ей значения отличен от "void", то мы будем создавать переменную, в которой мы будем хранить результат этой функции, а во всех местах использования "return" мы будем сохранять в эту переменную значение для возврата и делать безусловный переход на блок возврата из функции, который уже будет возвращать значение этой переменной (clang придерживается такого же подхода). Те кто писали на C, могли видеть такой подход, когда в функции было создание большого количества различных ресурсов (различных дескрипторов, выделение блоков памяти и т. п.), то для того что бы не производить очистку всех этих ресурсов в каждом месте с "return", создавался отдельный блок с меткой, который занимался очисткой всех этих ресурсов и управление с помощью "goto" передавалось на эту метку.</p><p>Например при данном подходе, функция main на языке C имеющая вид:</p><pre><code class="cpp">int main() {
  for (int i = 0; i &lt; 10; ++i) {
    if (i == 5) {
      break;
    }
  
    if (i == 2) {
      continue;
    }
  
    if (i == 7) {
      return 1;
    }
  
    printf("%d", i);
  }

  return 0;
}</code></pre><p>могла бы быть представлена в виде:</p><pre><code class="cpp">int main() {
  int result;
  {
    int i = 0;
loopcond:
    if (i &lt; 10) {
      goto loopbody;
    } else {
      goto loopend;
    }
loopbody:
    if (i == 5) {
      goto loopend;
    }
    if (i == 2) {
      goto postbody;
    }
    if (i == 7) {
      result = 1;
      goto return_point;
    }
    printf("%d", i);
postbody:
    ++i;
    goto loopcond;
loopend:
  }
  result = 0;
return_point:
  return result;
}</code></pre><p><strong>Замечание:</strong> В коде ниже применены некоторые оптимизации, которые позволяют убрать генерацию кода для блоков, которые никогда не будут вызваны. Например при генерации инструкций ветвления или циклов, часть кода может быть убрана, если истинность или ложность условия известна на этапе компиляции (Обрабатываются только простые выражения, вида 1, но не 1 + 2. Что бы сделать доступными более сложные конструкции, можно реализовать вычисление константных выражений на этапе семантического анализа).</p><p>Теперь рассмотрим генерацию кода для инструкций более подробно:</p><details class="spoiler"><summary>Hidden text</summary><div class="spoiler__content"><pre><code class="cpp">Value* StmtAST::generateCode(SLContext&amp; Context) {
  assert(0 &amp;&amp; "StmtAST::generateCode should never be reached");
  return nullptr;
}

Value* ExprStmtAST::generateCode(SLContext&amp; Context) {
  if (Expr) {
    // Генерация кода для выражения
    return Expr-&gt;getRValue(Context);
  }
  
  return nullptr;
}

llvm::Value* BlockStmtAST::generatePartialCode(SLContext&amp; Context, 
  StmtList::iterator it, StmtList::iterator end) {
  // Инициализируем блоки "break", "continue" и "return" для 
  // LandingPadAST текущего блока на основе родительского блока
  LandingPadAST* parent = LandingPad-&gt;Prev;
  LandingPad-&gt;BreakLoc = parent-&gt;BreakLoc;
  LandingPad-&gt;ContinueLoc = parent-&gt;ContinueLoc;
  LandingPad-&gt;ReturnLoc = parent-&gt;ReturnLoc;

  // Создаем новый блок FallthroughLoc (этот блок может быть 
  // использован в дочерних инструкциях, в качестве точки возврата 
  // (например для выхода из цикла))
  LandingPad-&gt;FallthroughLoc = BasicBlock::Create(
    getGlobalContext(),
    "block"
  );

  // Генерация кода для всех вложенных инструкций
  for (; it != end; ++it) {
    // Сохраняем FallthroughLoc (т. к. при использовании его 
    // вложенная инструкция должна будет его обнулить)
    BasicBlock* fallthroughBB = LandingPad-&gt;FallthroughLoc;
    lastFallThrough = LandingPad-&gt;FallthroughLoc;

    // Генерируем код для вложенной инструкции
    (*it)-&gt;generateCode(Context);

    // Проверяем была ли FallthroughLoc использована во вложенной 
    // инструкции или нет
    if (!LandingPad-&gt;FallthroughLoc) {
      // Была. Поэтому нужно добавить данный блок в конец функции, 
      // как ее часть и задать его в качестве точки для вставки
      // нового кода
      Context.TheFunction-&gt;getBasicBlockList().push_back(
        fallthroughBB
      );
      Context.TheBuilder-&gt;SetInsertPoint(fallthroughBB);

      // Записать в FallthroughLoc новый созданный блок, для 
      // последующего использования во вложенных инструкциях
      LandingPad-&gt;FallthroughLoc = BasicBlock::Create(
        getGlobalContext(),
        "block"
      );
    }
  }

  // Делаем подсчет количество "break" "continue" и "return" 
  // инструкций в данном блоке (в последующих статьях будет 
  // ясно зачем они нужны)
  parent-&gt;Breaks += LandingPad-&gt;Breaks;
  parent-&gt;Continues += LandingPad-&gt;Continues;
  parent-&gt;Returns += LandingPad-&gt;Returns;

  // Проверяем, что текущий блок имеет инструкцию завершения блока
  // (условный или безусловный переход)
  if (!Context.TheBuilder-&gt;GetInsertBlock()-&gt;getTerminator()) {
    // Нет. Генерируем инструкцию перехода на FallthroughLoc 
    // родительского блока и помечаем, ее как использованную 
    // (путем присвоения nullptr)
    Context.TheBuilder-&gt;CreateBr(parent-&gt;FallthroughLoc);
    parent-&gt;FallthroughLoc = nullptr;
    
    // Если FallthroughLoc, которую мы создали для вложенных 
    // инструкций не была использована, то производим ее очистку
    if (!LandingPad-&gt;FallthroughLoc-&gt;hasNUsesOrMore(1)) {
      delete LandingPad-&gt;FallthroughLoc;
    }
  // Проверяем, что  FallthroughLoc был использован во вложенных 
  // инструкциях
  } else if (LandingPad-&gt;FallthroughLoc-&gt;hasNUsesOrMore(1)) {
    // Был использован, нужно добавить его в конец функции, 
    // установить его в качестве места вставки нового кода, а 
    // также создаем безусловный переход на FallthroughLoc
    // родительского блока, а так же помечаем его как 
    // использованную (путем присвоения nullptr)
    Context.TheFunction-&gt;getBasicBlockList().push_back(
      LandingPad-&gt;FallthroughLoc
    );
    Context.TheBuilder-&gt;SetInsertPoint(LandingPad-&gt;FallthroughLoc);
    Context.TheBuilder-&gt;CreateBr(parent-&gt;FallthroughLoc);
    parent-&gt;FallthroughLoc = nullptr;
  } else {
    // Нет. Производим ее очистку
    delete LandingPad-&gt;FallthroughLoc;
  }

  return nullptr;
}

Value* BlockStmtAST::generateCode(SLContext&amp; Context) {
  return generatePartialCode(Context, Body.begin(), Body.end());
}

Value* DeclStmtAST::generateCode(SLContext&amp; Context) {
  // Генерируем код для каждого объявления
  for (SymbolList::iterator it = Decls.begin(), end = Decls.end();
    it != end; ++it) {
    (*it)-&gt;generateCode(Context);
  }

  return nullptr;
}

Value* LandingPadAST::getReturnValue() {
  LandingPadAST* prev = this;

  // Ищем LandingPadAST самого верхнего уровня (блок тела самой 
  // функции)
  while (prev-&gt;Prev) {
    prev = prev-&gt;Prev;
  }

  // Возвращаем (адрес переменной) возвращаемое значение функции
  return prev-&gt;ReturnValue;
}

Value* BreakStmtAST::generateCode(SLContext&amp; Context) {
  // Создать безусловный переход на метку "break" текущего цикла
  Context.TheBuilder-&gt;CreateBr(BreakLoc-&gt;BreakLoc);
  return nullptr;
}

Value* ContinueStmtAST::generateCode(SLContext&amp; Context) {
  // Создать безусловный переход на метку "continue" текущего цикла
  Context.TheBuilder-&gt;CreateBr(ContinueLoc-&gt;ContinueLoc);
  return nullptr;
}

Value* ReturnStmtAST::generateCode(SLContext&amp; Context) {
  // Проверяем, что у нас есть возвращаемое значение
  if (Expr) {
    // Генерируем код для выражения с возвращаемым значением
    Value* retVal = Expr-&gt;getRValue(Context);
    // Создаем инструкцию "store" для сохранения возвращаемого 
    // значения в переменной, для хранения результата выполнения
    // функции
    Context.TheBuilder-&gt;CreateStore(
      retVal,
      ReturnLoc-&gt;getReturnValue()
    );
    // Создаем безусловный переход на метку с выходом из функции
    Context.TheBuilder-&gt;CreateBr(ReturnLoc-&gt;ReturnLoc);
    return nullptr;
  }

  // Создаем безусловный переход на метку с выходом из функции
  Context.TheBuilder-&gt;CreateBr(ReturnLoc-&gt;ReturnLoc);
  return nullptr;
}

Value* WhileStmtAST::generateCode(SLContext&amp; Context) {
  LandingPadAST* prev = LandingPad-&gt;Prev;
  LandingPad-&gt;ReturnLoc = prev-&gt;ReturnLoc;

  // У нас есть оптимизация для варианта, если значение условия 
  // цикла известно на этапе компиляции (но мы не производим 
  // вычисление константных выражений вида 1 + 2, рассматриваем
  // только выражения вида 1)
  if (Cond-&gt;isConst()) {
    // Если условие имеет значение "false", то не генерируем код
    // вообще
    if (!Cond-&gt;isTrue()) {
      return nullptr;
    }

    // Создаем новые блоки для тела цикла и выхода из цикла, и 
    // устанавливаем их в качестве меток для "break" и "continue"
    BasicBlock* bodyBB = 
    LandingPad-&gt;ContinueLoc = BasicBlock::Create(
      getGlobalContext(),
      "loopbody",
      Context.TheFunction
    );
    BasicBlock* endBB = LandingPad-&gt;BreakLoc = BasicBlock::Create(
      getGlobalContext(), 
      "loopend"
    );

    if (PostExpr) {
      // Для циклов, которые были сделаны из цикла "for" и у 
      // которых есть блок для изменения переменных циклов, нам
      // нужно создать новый блок для этого кода и мы должны 
      // установить его в качестве метки "continue"
      LandingPad-&gt;ContinueLoc = BasicBlock::Create(
        getGlobalContext(),
        "postbody"
      );
    }

    // Создать безусловный переход на тело цикла и установить 
    // данный блок в качестве точки для генерации кода
    Context.TheBuilder-&gt;CreateBr(bodyBB);
    Context.TheBuilder-&gt;SetInsertPoint(bodyBB);

    // Устанавливаем точку для возврата из цикла в зависимости от 
    // того, есть ли блок для изменения переменных цикла или нет
    if (PostExpr) {
      LandingPad-&gt;FallthroughLoc = LandingPad-&gt;ContinueLoc;
    } else {
      LandingPad-&gt;FallthroughLoc = bodyBB;
    }

    // Генерируем код тела цикла
    Body-&gt;generateCode(Context);

    // У нас есть специальная обработка для циклов "for" с блоком 
    // для изменения переменных цикла
    if (PostExpr) {
      // Добавляем блок в конец функции и устанавливаем его в 
      // качестве точки генерации кода
      Context.TheFunction-&gt;getBasicBlockList().push_back(
        LandingPad-&gt;ContinueLoc
      );
      Context.TheBuilder-&gt;SetInsertPoint(LandingPad-&gt;ContinueLoc);

      // Генерируем код для выражения изменения переменных цикла
      PostExpr-&gt;getRValue(Context);
      // Генерируем безусловный переход на тело цикла
      Context.TheBuilder-&gt;CreateBr(bodyBB);
    }

    // Добавляем блок для возврата из цикла в конец функции и 
    // устанавливаем его в качестве точки генерации кода
    Context.TheFunction-&gt;getBasicBlockList().push_back(endBB);
    Context.TheBuilder-&gt;SetInsertPoint(endBB);
    prev-&gt;Returns += LandingPad-&gt;Returns;

    // Создаем безусловный переход на точку возврата родительского 
    // блока и помечаем ее как использованную (путем присвоения
    // nullptr)
    Context.TheBuilder-&gt;CreateBr(prev-&gt;FallthroughLoc);
    prev-&gt;FallthroughLoc = nullptr;

    return nullptr;
  }
  
  // Создаем новые блоки для условия цикла, его тела и выхода из 
  // него, и устанавливаем их в качестве меток для "break" 
  // и "continue"
  BasicBlock* condBB = LandingPad-&gt;ContinueLoc = BasicBlock::Create(
    getGlobalContext(), 
    "loopcond",
    Context.TheFunction
  );
  BasicBlock* bodyBB = BasicBlock::Create(
    getGlobalContext(), 
    "loopbody"
  );
  BasicBlock* endBB = LandingPad-&gt;BreakLoc = BasicBlock::Create(
    getGlobalContext(),
    "loopend"
  );

  if (PostExpr) {
    // Для циклов, которые были сделаны из цикла "for" и у которых 
    // есть блок для изменения переменных циклов, нам нужно создать
    // новый блок для этого кода и мы должны установить его в 
    // качестве метки "continue"
    LandingPad-&gt;ContinueLoc = BasicBlock::Create(
      getGlobalContext(),
      "postbody"
    );
  }

  // Создаем безусловный переход на блок с условием цикла и 
  // устанавливаем его в качестве точки генерации кода
  Context.TheBuilder-&gt;CreateBr(condBB);
  Context.TheBuilder-&gt;SetInsertPoint(condBB);

  // Генерируем код для условия цикла
  Value* cond = Cond-&gt;getRValue(Context);
  // Произвести преобразование в "bool"
  cond = promoteToBool(cond, Cond-&gt;ExprType, *Context.TheBuilder);
  // Создать условный переход на тело цикла или на выход из цикла 
  // в зависимости от истинности условия цикла
  Context.TheBuilder-&gt;CreateCondBr(cond, bodyBB, endBB);

  // Создать безусловный переход на тело цикла и установить данный
  // блок в качестве точки для генерации кода
  Context.TheFunction-&gt;getBasicBlockList().push_back(bodyBB);
  Context.TheBuilder-&gt;SetInsertPoint(bodyBB);

  // Устанавливаем точку для возврата из цикла в зависимости от
  // того, есть ли блок для изменения переменных цикла или нет
  if (PostExpr) {
    LandingPad-&gt;FallthroughLoc = LandingPad-&gt;ContinueLoc;
  } else {
    LandingPad-&gt;FallthroughLoc = condBB;
  }

  // Генерируем код тела цикла
  Body-&gt;generateCode(Context);

  // У нас есть специальная обработка для циклов "for" с блоком 
  // для изменения переменных цикла
  if (PostExpr) {
    // Добавляем блок в конец функции и устанавливаем его в 
    // качестве точки генерации кода
    Context.TheFunction-&gt;getBasicBlockList().push_back(
      LandingPad-&gt;ContinueLoc
    );
    Context.TheBuilder-&gt;SetInsertPoint(LandingPad-&gt;ContinueLoc);

    // Генерируем код для выражения изменения переменных цикла
    PostExpr-&gt;getRValue(Context);
    // Генерируем безусловный переход на условие цикла
    Context.TheBuilder-&gt;CreateBr(condBB);
  }

  // Добавляем блок для возврата из цикла в конец функции и 
  // устанавливаем его в качестве точки генерации кода
  Context.TheFunction-&gt;getBasicBlockList().push_back(endBB);
  Context.TheBuilder-&gt;SetInsertPoint(endBB);
  prev-&gt;Returns += LandingPad-&gt;Returns;

  // Создаем безусловный переход на точку возврата родительского 
  // блока и помечаем ее как использованную (путем присвоения 
  // nullptr)
  Context.TheBuilder-&gt;CreateBr(prev-&gt;FallthroughLoc);
  prev-&gt;FallthroughLoc = nullptr;

  return nullptr;
}

llvm::Value* ForStmtAST::generateCode(SLContext&amp; Context) {
  assert(0 &amp;&amp; "ForStmtAST::semantic should never be reached");
  return nullptr;
}

llvm::Value* IfStmtAST::generateCode(SLContext&amp; Context) {
  // Инициализируем блоки "break", "continue" и "return" для 
  // LandingPadAST текущего блока на основе родительского блока
  LandingPadAST* prev = LandingPad-&gt;Prev;
  LandingPad-&gt;ReturnLoc = prev-&gt;ReturnLoc;
  LandingPad-&gt;FallthroughLoc = prev-&gt;FallthroughLoc;
  LandingPad-&gt;ContinueLoc = prev-&gt;ContinueLoc;
  LandingPad-&gt;BreakLoc = prev-&gt;BreakLoc;

  // У нас есть оптимизация для варианта, если значение условия 
  // известно на этапе компиляции (но мы не производим вычисление
  // константных выражений вида 1 + 2, рассматриваем только
  // выражения вида 1)
  if (Cond-&gt;isConst()) {
    // Если выражение истинно
    if (Cond-&gt;isTrue()) {
      // Генерируем код для ветки "then"
      ThenBody-&gt;generateCode(Context);

      // Делаем подсчет количество "break" "continue" и "return" 
      // инструкций в данном блоке (в последующих статьях будет
      // ясно зачем они нужны)
      prev-&gt;Returns += LandingPad-&gt;Returns;
      prev-&gt;Breaks += LandingPad-&gt;Breaks;
      prev-&gt;Continues += LandingPad-&gt;Continues;

      if (!Context.TheBuilder-&gt;GetInsertBlock()-&gt;getTerminator()) {
        // Если еще нет условного или безусловного перехода, то 
        // создаем безусловный переход на точку возврата 
        // родительского блока и помечаем ее как использованную 
        // (путем присвоения nullptr)
        Context.TheBuilder-&gt;CreateBr(prev-&gt;FallthroughLoc);
        prev-&gt;FallthroughLoc = nullptr;
      }

      return nullptr;
    }
      
    // Если выражение ложно и у нас есть ветка "else"
    if (ElseBody) {
      // Генерируем код для ветки "else"
      ElseBody-&gt;generateCode(Context);

      // Делаем подсчет количество "break" "continue" и "return" 
      // инструкций в данном блоке (в последующих статьях будет
      // ясно зачем они нужны)
      prev-&gt;Returns += LandingPad-&gt;Returns;
      prev-&gt;Breaks += LandingPad-&gt;Breaks;
      prev-&gt;Continues += LandingPad-&gt;Continues;

      if (!Context.TheBuilder-&gt;GetInsertBlock()-&gt;getTerminator()) {
        // Если еще нет условного или безусловного перехода, то
        // создаем безусловный переход на точку возврата 
        // родительского блока и помечаем ее как использованную
        // (путем присвоения nullptr)
        Context.TheBuilder-&gt;CreateBr(prev-&gt;FallthroughLoc);
        prev-&gt;FallthroughLoc = nullptr;
      }
    }

    return nullptr;
  }
   
  // Генерируем код для условного выражения
  Value* cond = Cond-&gt;getRValue(Context);
  // Произвести преобразование в "bool"
  cond = promoteToBool(cond, Cond-&gt;ExprType, *Context.TheBuilder);

  // Создаем блок для веток "then" и блока за инструкцией ветвления
  BasicBlock* thenBB = BasicBlock::Create(
    getGlobalContext(),
    "thenpart", 
    Context.TheFunction
  );
  BasicBlock* elseBB = nullptr;
  BasicBlock* endBB = BasicBlock::Create(
    getGlobalContext(),
    "ifcont"
  );

  // Проверяем наличие ветки "else"
  if (ElseBody) {
    // Создаем блок для ветки "else"
    elseBB = BasicBlock::Create(getGlobalContext(), "elsepart");
    // Создаем условный переход на "then" или "else" в зависимости 
    // от истинности условия
    Context.TheBuilder-&gt;CreateCondBr(cond, thenBB, elseBB);
  } else {
    // Создаем условный переход на "then" или блок за инструкцией 
    // ветвления в зависимости от истинности условия
    Context.TheBuilder-&gt;CreateCondBr(cond, thenBB, endBB);
  }

  // Устанавливаем точку для генерации кода на блок "then"
  Context.TheBuilder-&gt;SetInsertPoint(thenBB);
  
  // Устанавливаем точку для FallthroughLoc
  LandingPad-&gt;FallthroughLoc = endBB;

  // Генерируем код для ветви "then"
  ThenBody-&gt;generateCode(Context);

  // Устанавливаем точку для FallthroughLoc (т. к. она могла быть 
  // обнулена при генерации кода для ветки "then")
  LandingPad-&gt;FallthroughLoc = endBB;

  // Проверяем наличие ветки "else"
  if (ElseBody) {
    // Добавляем блок "else" в конец функции и устанавливаем его в 
    // качестве точки генерации кода
    Context.TheFunction-&gt;getBasicBlockList().push_back(elseBB);
    Context.TheBuilder-&gt;SetInsertPoint(elseBB);

    // Генерируем код для ветви "else"
    ElseBody-&gt;generateCode(Context);
  }

  // Проверяем был ли использован блок, который мы создали для 
  // продолжения выполнения после инструкции ветвления
  if (endBB-&gt;hasNUsesOrMore(1)) {
    // Добавляем данный блок в конец функции и устанавливаем его в 
    // качестве точки генерации кода
    Context.TheFunction-&gt;getBasicBlockList().push_back(endBB);
    Context.TheBuilder-&gt;SetInsertPoint(endBB);

    // Создаем безусловный переход на точку возврата родительского 
    // блока и помечаем ее как использованную (путем присвоения
    // nullptr)
    Context.TheBuilder-&gt;CreateBr(prev-&gt;FallthroughLoc);
    prev-&gt;FallthroughLoc = nullptr;
  } else {
    // Производим очистку
    delete endBB;
  }

  // Делаем подсчет количество "break" "continue" и "return" 
  // инструкций в данном блоке (в последующих статьях будет
  // ясно зачем они нужны)
  prev-&gt;Returns += LandingPad-&gt;Returns;
  prev-&gt;Breaks += LandingPad-&gt;Breaks;
  prev-&gt;Continues += LandingPad-&gt;Continues;

  return nullptr;
}</code></pre><p></p></div></details><h3>Генерация кода для объявлений</h3><p>Рассмотрим изменения которые необходимы для генерации кода для объявлений:</p><pre><code class="cpp">struct SymbolAST { 
  /// Генерация объявления символа (например переменной)
  virtual llvm::Value *getValue(SLContext &amp;Context); 
  /// Генерация кода для символа (тела функции, инициализаторов и т. п.)
  virtual llvm::Value *generateCode(SLContext &amp;Context); 
}; </code></pre><p>Рассмотрим саму генерацию кода для объявлений:</p><details class="spoiler"><summary>Hidden text</summary><div class="spoiler__content"><pre><code class="cpp">Value* SymbolAST::getValue(SLContext&amp; ) {
  assert(0 &amp;&amp; "SymbolAST::getValue should never be reached");
  return nullptr;
}

Value* SymbolAST::generateCode(SLContext&amp; Context) {
  assert(0 &amp;&amp; "SymbolAST::generateCode should never be reached");
  return nullptr;
}

Value* VarDeclAST::generateCode(SLContext&amp; Context) {
  assert(SemaState &gt;= 5);
  // Получаем адрес переменной (т. к. память под саму переменную 
  // уже должна была выделена ранее во время генерации кода для
  // функции)
  Value* val = getValue(Context);


  // Если у нас есть выражение инициализации, то нужно ее 
  // произвести
  if (Val) {
    // Генерация кода для инициализирующего выражения
    Value* init = Val-&gt;getRValue(Context);

    // Создание инструкции "store"
    return Context.TheBuilder-&gt;CreateStore(init, val);
  }

  return val;
}

Value* VarDeclAST::getValue(SLContext&amp; Context) {
  // Генерируем код для объявления только один раз
  if (CodeValue) {
    return CodeValue;
  }

  // Создаем инструкцию "alloca" для переменной
  CodeValue = Context.TheBuilder-&gt;CreateAlloca(
    ThisType-&gt;getType(),
    0,
    StringRef(Id-&gt;Id, Id-&gt;Length)
  );
  return CodeValue;
}

llvm::Value* ParameterSymbolAST::getValue(SLContext&amp; Context) {
  // Генерируем код для объявления только один раз
  if (Param-&gt;CodeValue) {
    return Param-&gt;CodeValue;
  }

  // Создаем инструкцию "alloca" для параметра функции
  Param-&gt;CodeValue = Context.TheBuilder-&gt;CreateAlloca(
    Param-&gt;Param-&gt;getType(),
    0U
  );
  return Param-&gt;CodeValue;
}

llvm::Value* ParameterSymbolAST::generateCode(SLContext&amp; Context) {
  assert(SemaState &gt;= 5);
  // Мы только генерируем адрес для переменной, все остальное при 
  // необходимости будет сгенерировано в  FuncDeclAST
  return getValue(Context);
}

Value* FuncDeclAST::getValue(SLContext&amp; Context) {
  // Генерируем код для объявления только один раз
  if (CodeValue) {
    return CodeValue;
  }

  SmallString&lt; 128 &gt; str;
  raw_svector_ostream output(str);

  // Производим генерацию имени функции (для "main" у нас есть 
  // специальная обработка)
  if (!(Id-&gt;Length == 4 &amp;&amp; memcmp(Id-&gt;Id, "main", 4) == 0)) {
    // Генерация уникального декорированного имени функции
    output &lt;&lt; "_P" &lt;&lt; Id-&gt;Length &lt;&lt; StringRef(Id-&gt;Id, Id-&gt;Length);
    ThisType-&gt;toMangleBuffer(output);
  } else {
    output &lt;&lt; "main";
  }

  // Создать функцию с внешним видом связанности для данного 
  // объявления
  CodeValue = Function::Create((FunctionType*)ThisType-&gt;getType(), 
    Function::ExternalLinkage, output.str(), nullptr);
  Context.TheModule-&gt;getFunctionList().push_back(CodeValue);

  return CodeValue;
}

Value* FuncDeclAST::generateCode(SLContext&amp; Context) {
  if (Compiled) {
    return CodeValue;
  }

  assert(SemaState &gt;= 5);
  // Создать объявление функции (ее прототип)
  getValue(Context);

  BasicBlock* oldBlock = Context.TheBuilder-&gt;GetInsertBlock();

  Function::arg_iterator AI = CodeValue-&gt;arg_begin();
  ParameterList::iterator PI = 
    ((FuncTypeAST*)ThisType)-&gt;Params.begin();
  ParameterList::iterator PE = 
    ((FuncTypeAST*)ThisType)-&gt;Params.end();

  // Создать блок "entry" для тела функции и установить его в 
  // качестве точки генерации кода
  BasicBlock* BB = BasicBlock::Create(
    getGlobalContext(), 
    "entry", 
    CodeValue
  );
  Context.TheBuilder-&gt;SetInsertPoint(BB);

  // Выделение памяти для всех объявленных переменных
  for (std::vector&lt; SymbolAST* &gt;::iterator it = FuncVars.begin(), 
    end = FuncVars.end(); it != end; ++it) {
    (*it)-&gt;getValue(Context);
  }

  // Произвести генерацию кода для всех параметров
  for ( ; PI != PE; ++PI, ++AI) {
    ParameterAST* p = *PI;

    // Нам важны только именованные параметры
    if (p-&gt;Id) {
      // Указание имени параметра
      AI-&gt;setName(StringRef(p-&gt;Id-&gt;Id, p-&gt;Id-&gt;Length));
      // Генерация инструкции "alloca", если это необходимо
      if (!p-&gt;CodeValue) {
        p-&gt;CodeValue = Context.TheBuilder-&gt;CreateAlloca(
          p-&gt;Param-&gt;getType(),
          0U
        );
      }
      // Генерируем инструкцию "store" для копирования значения 
      // переданного в функцию в качестве параметра в переменную
      // выделенную под этот параметр
      Context.TheBuilder-&gt;CreateStore(AI, p-&gt;CodeValue);
    }
  }

  // Если тип возвращаемого значения функции отличается от "void",
  // то выделяем память для переменной, которая будет хранить
  // значение данной функции
  if (!ReturnType-&gt;isVoid()) {
    LandingPad-&gt;ReturnValue = Context.TheBuilder-&gt;CreateAlloca(
      ReturnType-&gt;getType(),
      0U,
      "return.value"
    );
  }

  // Создать блок для возврата из функции и установить его в 
  // качестве FallthroughLoc
  LandingPad-&gt;ReturnLoc = BasicBlock::Create(
    getGlobalContext(),
    "return.block"
  );
  LandingPad-&gt;FallthroughLoc = LandingPad-&gt;ReturnLoc;

  Function* oldFunction = Context.TheFunction;
  Context.TheFunction = CodeValue;

  // Генерация кода для тела функции
  Body-&gt;generateCode(Context);
 
  Context.TheFunction = oldFunction;

  // Добавляем условный переход на блок выхода из функции, если 
  // он еще не был сгенерирован
  if (!Context.TheBuilder-&gt;GetInsertBlock()-&gt;getTerminator()) {
    Context.TheBuilder-&gt;CreateBr(LandingPad-&gt;ReturnLoc);
  }

  // Добавить блок для возврата из функции в конец функции и 
  // установить его в качестве точки генерации кода
  CodeValue-&gt;getBasicBlockList().push_back(LandingPad-&gt;ReturnLoc);
  Context.TheBuilder-&gt;SetInsertPoint(LandingPad-&gt;ReturnLoc);
  
  if (!ReturnType-&gt;isVoid()) {
    // Тип возвращаемого значение не "void". Создаем инструкцию 
    // "load" для загрузки возвращаемого значения
    Value* ret = Context.TheBuilder-&gt;CreateLoad(
      ReturnType-&gt;getType(),
      LandingPad-&gt;ReturnValue
    );
    // Генерация инструкции возврата из функции
    Context.TheBuilder-&gt;CreateRet(ret);
  } else {
    // Генерация инструкции возврата из функции для "void"
    Context.TheBuilder-&gt;CreateRetVoid();
  }

  // Восстановление предыдущей точки генерации кода (если нужно)
  if (oldBlock) {
    Context.TheBuilder-&gt;SetInsertPoint(oldBlock);
  }

  // Проверка кода функции и оптимизация (если она включена)
  verifyFunction(*CodeValue, &amp;llvm::errs());
  
  Compiled = true;

  return CodeValue;
}

void ModuleDeclAST::generateCode() {
  SLContext&amp; Context = getSLContext();
  
  // Генерируем код для всех объявлений
  for (SymbolList::iterator it = Members.begin(),
    end = Members.end(); it != end; ++it) {
    (*it)-&gt;generateCode(Context);
  }

  // Печать кода модуля на консоль
  Context.TheModule-&gt;dump();

  if (!OutputFilename.empty()) {
    std::error_code errorInfo;
    raw_fd_ostream fd(OutputFilename.c_str(), errorInfo);

    if (errorInfo) {
      llvm::errs()
        &lt;&lt; "Can't write to \""
        &lt;&lt; OutputFilename.c_str()
        &lt;&lt; "\" file\n";
    }

    // Печать кода модуля в результирующий файл, если он был задан
    Context.TheModule-&gt;print(fd, 0);
  }

  // Получить адрес JIT функции для "main", которую можно вызвать 
  // для запуска приложения
  MainPtr = (double (*)())(intptr_t)getJITMain();
}</code></pre><p></p></div></details><h3>Заключение</h3><p>В данной части мы рассмотрели генерацию кода для LLVM IR, рассмотрели базовые концепции LLVM и LLVM IR. Так же были рассмотрены некоторые концепции, которые позволяют упростить генерацию кода и производить различные оптимизации на их основе.</p><p>Полный исходный код доступен на <a href="https://github.com/dc-sinpo/simple/tree/part01" rel="noopener noreferrer nofollow">github</a>. В следующих статьях мы будем расширять возможности подмножества нашего учебного языка и добавим конструкции более высокого уровня, такие как:</p><ol><li><p>Указатели и массивы;</p></li><li><p>Структуры и классы;</p></li><li><p>Наследование и динамическая диспетчеризация методов объектов класса;</p></li><li><p>А так же перегрузку функций.</p></li></ol><h3>Полезные ссылки</h3><ol><li><p><a href="https://llvm.org/docs/LangRef.html" rel="noopener noreferrer nofollow">https://llvm.org/docs/LangRef.html</a></p></li><li><p><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html" rel="noopener noreferrer nofollow">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p></li><li><p><a href="https://llvm.org/docs/tutorial/BuildingAJIT1.html" rel="noopener noreferrer nofollow">https://llvm.org/docs/tutorial/BuildingAJIT1.html</a></p></li></ol><p></p></div></div></div> <!-- --> <!-- --></div> <!-- --> <!-- --></div> <!-- --> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bllvm%5D">llvm</a></li><li class="tm-separated-list__item"><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B%5D">компиляторы</a></li><li class="tm-separated-list__item"><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B%5D">c++</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a class="tm-hubs-list__link" href="/ru/hub/open_source/">Open source</a></li><li class="tm-separated-list__item"><a class="tm-hubs-list__link" href="/ru/hub/programming/">Программирование</a></li><li class="tm-separated-list__item"><a class="tm-hubs-list__link" href="/ru/hub/compilers/">Компиляторы</a></li></ul></div></div></article></div> <!-- --></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 5: ↑5 и ↓0</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#counter-rating"></use></svg> <span class="tm-votes-meter__value tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating" title="Всего голосов 5: ↑5 и ↓0">+5</span></div> <div class="v-portal" style="display:none;"></div></div> <!-- --> <!-- --> <button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#counter-favorite"></use></svg></span> <span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">
    21
  </span></button> <div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" href="/ru/post/717886/comments/"><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value">
      1
    </span></a> <!-- --></div> <div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button> <div class="v-portal" style="display:none;"></div></div> <div class="v-portal" style="display:none;"></div></div> </div></div> <div class="v-portal" style="display:none;"></div> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!-- --> <section class="tm-block tm-block tm-block_spacing-bottom"><!-- --> <div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/DCSinpo/"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!-- --> <use xlink:href="/img/megazord-v28.78dd0d98..svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div class="tm-karma tm-user-card__karma tm-karma" title=" 20 голосов "><div class="tm-karma__votes tm-karma__votes_positive">
    18
  </div> <div class="tm-karma__text">
    Карма
  </div> <div class="v-portal" style="display:none;"></div></div> <div class="tm-rating tm-user-card__rating" title="Рейтинг пользователя"><div class="tm-rating__header"> <div class="tm-rating__counter tm-rating__counter">57.1</div></div> <div class="tm-rating__text tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name tm-user-card__name_variant-article">Илья Моисеенко</span> <a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/DCSinpo/">
          @DCSinpo
        </a> <!-- --></div> <p class="tm-user-card__short-info tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons tm-user-card__buttons_variant-article"><!-- --> <!-- --> <!-- --> <!-- --> <!-- --></div></div> <!-- --></div> <div class="v-portal" style="display:none;"></div></div> <!-- --></section> <div class="tm-adfox-banner__container tm-page-article__banner"><!-- --> <div class="tm-adfox-banner tm-adfox-banner tm-adfox-banner_variant-leaderboard" id="adfox_164725660339535756"></div></div> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" href="/ru/post/717886/comments/"><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 1 
    </span></a> <!-- --></div></div></div> <section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2> </div> <!-- --></header> <div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><div class="tm-tabs tm-tabs"><div><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim">
        Лучшие за сутки
      </button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link tm-tabs__tab-link_slim">
        Похожие
      </button></span></div> <!-- --></div> <div class="similar-and-daily__tab-view"><div><!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <div class="tm-placeholder-article-cards"><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div> <div class="tm-placeholder__user-date loads"></div></div> <div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div> <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div> <div class="tm-placeholder-article-card__icons tm-placeholder__counters"><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div> <div class="tm-placeholder__user-date loads"></div></div> <div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div> <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div> <div class="tm-placeholder-article-card__icons tm-placeholder__counters"><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div> <div class="tm-placeholder__user-date loads"></div></div> <div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div> <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div> <div class="tm-placeholder-article-card__icons tm-placeholder__counters"><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div> <div class="tm-placeholder__user-date loads"></div></div> <div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div> <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div> <div class="tm-placeholder-article-card__icons tm-placeholder__counters"><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div> <div class="tm-placeholder__user-date loads"></div></div> <div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div> <div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div> <div class="tm-placeholder-article-card__icons tm-placeholder__counters"><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div> <div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div></div></div></div> <!-- --> <!-- --> <!-- --> <!-- --></div> <!-- --></div></div> <!-- --></section> <div><div><!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div> <div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div> <div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div> <div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div> <div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div> <div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div> <div class="tm-placeholder-promo__dot"></div> <div class="tm-placeholder-promo__dot"></div></div></div></div> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --></div></div> <div><div><!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <div class="tm-placeholder-inset tm-placeholder-salary"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div> <div class="tm-placeholder-salary__body"><div class="tm-placeholder-salary__text"><div class="tm-placeholder__line tm-placeholder__line_salary_average"></div> <div class="tm-placeholder-salary__description"><div class="tm-placeholder__line loads"></div> <div class="tm-placeholder__line loads"></div> <div class="tm-placeholder__line loads"></div> <div class="tm-placeholder__line loads"></div></div></div> <div class="tm-placeholder-salary__image loads"></div></div> <div class="tm-placeholder-inset__footer tm-placeholder-inset__footer_salary"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --> <!-- --></div></div> <!-- --> <section class="tm-block tm-stories-block tm-block tm-block_spacing-top" data-async-called="true" data-navigatable="" tabindex="0"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Истории</h2> </div> <!-- --></header> <div class="tm-block__body tm-block__body tm-block__body_variant-equal"><div class="tm-stories-empty"><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div> <div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div> <div class="tm-stories-card-empty__title-block"></div></div></div></div> <!-- --></div> <!-- --></section> <!-- --></div></div></div></div></div> <div class="tm-page__sidebar"><!-- --></div></div></div></div></main> <!-- --></div> <!-- --> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><div class="tm-footer__title"><a class="tm-svg-icon__wrapper tm-footer__title-link router-link-active" href="/ru/"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a></div> <div class="tm-footer__social"><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <div class="v-portal" style="display:none;"></div> <button class="tm-footer__link"><svg class="tm-svg-img tm-footer__icon" height="16" width="16"><title>Язык</title> <use xlink:href="/img/megazord-v28.78dd0d98..svg#lang"></use></svg>
        Настройка языка
      </button> <a class="tm-footer__link" href="/ru/feedback/">
        Техническая поддержка
      </a> <a class="tm-footer__link" href="/berserk-mode-nope">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2023, </span> <span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div></div></div> <!-- --> <!-- --></div> <div class="vue-portal-target"></div></div>








</body>
</html>
